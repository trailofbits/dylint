#![feature(rustc_private)]
#![warn(unused_extern_crates)]

extern crate rustc_hir;
extern crate rustc_middle;
extern crate rustc_span;

use clippy_utils::diagnostics::span_lint_and_help;
use rustc_hir::{Body, FnDecl, intravisit::FnKind};
use rustc_lint::{LateContext, LateLintPass};
use rustc_middle::ty;
use rustc_span::{
    Span,
    def_id::{DefId, LocalDefId},
};

dylint_linting::declare_late_lint! {
    /// ### What it does
    ///
    /// Checks for functions that take `Iterator` trait bounds when they could use
    /// `IntoIterator` instead.
    ///
    /// ### Why is this bad?
    ///
    /// Using `IntoIterator` makes functions more flexible by allowing them to
    /// accept more types like arrays, slices, and `Vec` without requiring explicit
    /// `.iter()` calls. This often makes the API easier to use.
    ///
    /// ### Example
    ///
    /// ```rust
    /// // Bad: Requires caller to call .iter() on Vec, slice, etc.
    /// fn process_bad<I: Iterator<Item = u32>>(iter: I) {
    ///     for item in iter {
    ///         // ...
    ///     }
    /// }
    /// ```
    ///
    /// Good: Accepts Vec, slice, etc. directly.
    ///
    /// ```rust
    /// fn process_good<I: IntoIterator<Item = u32>>(iterable: I) {
    ///     for item in iterable { // .into_iter() is implicitly called
    ///         // ...
    ///     }
    /// }
    /// ```
    ///
    /// This lint ignores cases where the parameter is also bounded by other traits
    /// (besides the implicit `Sized`), as `IntoIterator` might not be suitable.
    ///
    /// ```rust
    /// fn complex_bound<I: Iterator + Clone>(iter: I) { // Ok
    ///     // ...
    /// }
    /// ```

    pub ARG_ITER,
    Warn,
    "functions taking `Iterator` trait bounds when `IntoIterator` would be more flexible"
}

impl<'tcx> LateLintPass<'tcx> for ArgIter {
    fn check_fn(
        &mut self,
        cx: &LateContext<'tcx>,
        kind: FnKind<'tcx>,
        decl: &'tcx FnDecl<'tcx>,
        _body: &'tcx Body<'tcx>,
        span: Span,
        id: LocalDefId,
    ) {
        if matches!(kind, FnKind::Closure) {
            return;
        }

        // Don't lint functions generated by macros (e.g. derive, attribute macros)
        if span.from_expansion() {
            return;
        }

        let Some(iterator_def_id) = cx.tcx.lang_items().iterator_trait() else {
            return;
        };
        let Some(sized_def_id) = cx.tcx.lang_items().sized_trait() else {
            return;
        };

        let predicates = cx.tcx.predicates_of(id);

        let fn_sig = cx.tcx.fn_sig(id).skip_binder();

        for (i, input_ty) in fn_sig.inputs().iter().enumerate() {
            let input_ty_skipped_binder: &ty::Ty = input_ty.skip_binder(); // Skip binder once
            if let ty::TyKind::Param(param_ty) = input_ty_skipped_binder.kind() {
                // Check if this parameter is bound only by Iterator
                if is_param_bound_only_by_iterator(
                    predicates,
                    *input_ty_skipped_binder,
                    iterator_def_id,
                    sized_def_id,
                ) && !is_param_used_in_other_trait_args(
                    predicates,
                    *input_ty_skipped_binder,
                    iterator_def_id,
                    sized_def_id,
                ) {
                    let input_hir_ty = &decl.inputs[i];
                    span_lint_and_help(
                        cx,
                        ARG_ITER,
                        input_hir_ty.span,
                        "parameter type has `Iterator` bound",
                        None,
                        format!(
                            "consider using `IntoIterator` instead of `Iterator` for parameter `{}`",
                            param_ty.name
                        ),
                    );
                }
            }
        }
    }
}

/// Checks if a given type parameter `param_ty` is bound _only_ by `iterator_def_id`
/// within the given `predicates`
fn is_param_bound_only_by_iterator<'tcx>(
    predicates: ty::GenericPredicates<'tcx>,
    param_ty: ty::Ty<'tcx>,
    iterator_def_id: DefId,
    sized_def_id: DefId,
) -> bool {
    let mut found_iterator_bound = false;

    for &(predicate, _pred_span) in predicates.predicates.iter() {
        if let Some(trait_pred) = predicate.as_trait_clause() {
            let bound_trait_pred = trait_pred.skip_binder();
            let self_ty = bound_trait_pred.self_ty();

            if self_ty == param_ty {
                let current_trait_def_id = bound_trait_pred.def_id();

                if current_trait_def_id == iterator_def_id {
                    found_iterator_bound = true;
                } else if current_trait_def_id != sized_def_id {
                    return false;
                }
            }
        }
    }

    found_iterator_bound
}

/// Checks if the given parameter type `param_ty` is used as an argument
fn is_param_used_in_other_trait_args<'tcx>(
    predicates: ty::GenericPredicates<'tcx>,
    param_ty: ty::Ty<'tcx>,
    iterator_def_id: DefId,
    sized_def_id: DefId,
) -> bool {
    for &(predicate, _) in predicates.predicates.iter() {
        if let Some(trait_pred) = predicate.as_trait_clause() {
            let bound_trait_pred = trait_pred.skip_binder();
            let current_trait_def_id = bound_trait_pred.def_id();

            if current_trait_def_id == iterator_def_id || current_trait_def_id == sized_def_id {
                continue;
            }

            for arg in bound_trait_pred.trait_ref.args.iter() {
                if arg.as_type() == Some(param_ty) {
                    return true;
                }
            }
        }
    }
    false
}

#[test]
fn ui() {
    dylint_testing::ui_test(env!("CARGO_PKG_NAME"), "ui");
}
